# Semantic Analysis for the DSL for Simplicial Complexes

The mathematical definitions of simplicial complexes and related concepts are provided in the documentation (see [here](docs/mathematics.md)).

## Semantic Domains

### Simplicial Complexes
The foundamental mathematical objects manipulated by the language are simpcial complexes. 
<center>
 Complex := { K | K is a simplicial complex }
</center>
### Locations
Memory locations are use to store simplicial complexes
<center>
 Loc := $\mathbb{N}$
</center>

### Values
The language distinguishes between two types of values: 
- **Denotable Values**: These are either integers or memory locations.
<center>
      DVal := $\mathbb{Z}$ + Loc
</center>
- **Storable Values**: These are simplicial complexes.
<center>
      SVal := Complex
</center>

Integers arise only as observable values.

### Enviroment
An environment maps identifiers to denotable values.
<center>
      Env := Id → DVal
</center>

Let $\rho$ ∈ Env be an environment, an enviroment update is defined as:
<center>
      $\rho$[d/x] := λy. if y = x then
             d
        else
             $\rho$(y)
</center>

### Store
A store maps memory locations to storable values.
<center>
      Store := Loc → SVal
</center>

Update a store $\sigma$ ∈ Store at location l ∈ Loc with storable value K ∈ SVal is written as $\sigma[K/l]$

### Program State
A program state is a pair consisting of an environment and a store.
<center>
      State := Env × Store
</center>

### Programs and Commands
A program is a finite sequence of commands.
<center>
      Prog := Command*
</center>
The semantic of a program is a function from an initial program state to a final program state.
<center>
      [[s1; ...; sn]] : State → State
</center>

### Denotational Semantics of Commands
The denotational semantics of commands is defined as follows:
- **Complex Definition**:
```
complex K = [A, B, C]
```
The semantics of defining a simplicial complex K with maximal simplex {A, B, C} is given by:
<center>
      [[complex K = [A, B, C]]]($\rho$, $\sigma$) = ($\rho$[l/x], $\sigma$[K/l]) where l ∉ dom($\sigma$) and K is the simplicial complex generated by the maximal simplex {A, B, C}.
</center>

- **Assignment**:
```
K = expr
```
The semantics of assigning to K the union of simplicial complexes K1 and K2 is given
by:
<center>
      [[K = expr]]($\rho$, $\sigma$) = ($\rho$, $\sigma$[K/l]) where l = $\rho$(K) and expr evaluates to a simplicial complex K.
</center>

### Denotational Semantics of Expressions
The denotational semantics of expressions that evaluate to simplicial complexes is defined as follows:

- **Union of Complexes**:
```
union(expr, expr)
```
The semantics of the union of two simplicial complexes K1 and K2 is given by:
<center>
      [[union(expr1, expr2)]]($\rho$, $\sigma$) = K1 ∪ K2 where K1 = [[expr1]]($\rho$, $\sigma$) and K2 = [[expr2]]($\rho$, $\sigma$).
</center>

- **Gluing of Complexes**:
```
glue(expr1, expr2) mapping {v1 -> v2, ...}
```
The semantics of gluing two simplicial complexes K1 and K2 along specified vertices is given by:
<center>
      [[glue(expr1, expr2) mapping {v1 -> v2, ...}]]($\rho$, $\sigma$) = K where K is the simplicial complex obtained by gluing K1 and K2 along the specified vertex identifications.
</center>

- **Join of Complexes**:
```join(expr1, expr2)
```
The semantics of the join of two simplicial complexes K1 and K2 is given by:
<center>
      [[join(expr1, expr2)]]($\rho$, $\sigma$) = K where K is the simplicial complex obtained by taking the join of K1 and K2.
</center>

The expressions that evaluate to integers are defined as follows:

- **Dimension of Complex**:
```
dim(expr)
```
The semantics of calculating the dimension of a simplicial complex K is given by:
<center>
      [[dim(expr)]]($\rho$, $\sigma$) = d where K = [[expr]]($\rho$, $\sigma$) and d is the dimension of K.
</center>

## Control Flow Constructs
The language includes standard control flow constructs such as conditionals and loops.
- **Conditionals**:
```
if condition then
    statement
else
    statement
endif
```
The semantics of the conditional statement is given by:
<center>
      [[if condition then s1 else s2 endif]]($\rho$, $\sigma$) = 
        if [[condition]]($\rho$, $\sigma$) ≠ 0 then
            [[s1]]($\rho$, $\sigma$)
        else
            [[s2]]($\rho$, $\sigma$)
</center>

- **Loops**:
```
while condition do
    statement
endwhile
```
The semantics of the while loop is given by:
<center>
      [[while condition do s endwhile]]($\rho$, $\sigma$) =
        if [[condition]]($\rho$, $\sigma$) ≠ 0 then
            [[while condition do s endwhile]]([[s]]($\rho$, $\sigma$))
        else
            ($\rho$, $\sigma$)
</center>


